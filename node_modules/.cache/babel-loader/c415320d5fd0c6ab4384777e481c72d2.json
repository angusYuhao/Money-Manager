{"ast":null,"code":"var _jsxFileName = \"/Users/emilyhuang/Documents/CSC309/groupProject/team06/src/components/Investments/BarChart.js\";\n//Tutorials followed:\nimport React, { useRef, useEffect, useReducer } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass BarChart extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      canvasWidth: 1200,\n      canvasHeight: 600,\n      bars: [],\n      graphWidth: 1000,\n      //style this in css to add padding on left and right\n      graphHeight: 500\n    };\n\n    this.randomPastelColourCode = () => {\n      return \"hsl(\" + 360 * Math.random() + ',' + (25 + 70 * Math.random()) + '%,' + (80 + 10 * Math.random()) + '%)';\n    };\n\n    this.drawBars = () => {\n      //!!!Ian: bookCost is the total amount spend on that stock/in that category\n      const {\n        listToDisplay\n      } = this.props;\n      let total = listToDisplay.reduce((ttl, stock) => {\n        return ttl + stock.bookCost;\n      }, 0); //get the max and min gain loss stocks\n\n      const maxAmount = listToDisplay.reduce(function (prev, current) {\n        return prev.gainLoss > current.gainLoss ? prev : current;\n      });\n      console.log(maxAmount);\n      const minAmount = listToDisplay.reduce(function (prev, current) {\n        return prev.gainLoss < current.gainLoss ? prev : current;\n      });\n      console.log(minAmount); //based on the max and min values, calculate the corresponding ratios for the bar graph\n\n      let amountVertical = 0;\n      let axisPosition = 0;\n      let elem = document.getElementById('barChartCanvas');\n      let rect = elem.getBoundingClientRect();\n\n      if (minAmount.gainLoss < 0) {\n        console.log(\"DRAWING\");\n        amountVertical = maxAmount - minAmount; // axisPosition = (maxAmount/amountVertical) * this.graphHeight;\n\n        axisPosition = 1110;\n        this.context.lineWidth = 3;\n        this.context.strokeStyle = '#56525A';\n        this.context.beginPath();\n        this.context.moveTo(100, 1200);\n        this.context.lineTo(1100, 700);\n        this.context.stroke();\n        this.context.closePath();\n      } else {\n        amountVertical = maxAmount;\n      } // listToDisplay.forEach(element => {\n      //     //here the slices are draw backwards...(clockwise) so makesure to push into the list properly\n      //     this.context.lineWidth = 3;\n      //     this.context.strokeStyle = '#fafafa';\n      //     this.context.fillStyle = this.randomPastelColourCode();\n      //     let sliceColour = this.context.fillStyle;\n      //     this.context.beginPath();\n      //     // draw the pie wedges\n      //     let endAngle = ((element.bookCost / total) * Math.PI * 2) + startAngle;\n      //     this.context.moveTo(cx, cy);\n      //     this.context.arc(cx, cy, radius, startAngle, endAngle);\n      //     this.context.lineTo(cx, cy);\n      //     this.context.fill();\n      //     this.context.stroke();\n      //     this.context.closePath();\n      //     // add the labels\n      //     this.context.beginPath();\n      //     this.context.font = '20px Helvetica, Calibri';\n      //     this.context.textAlign = 'center';\n      //     this.context.fillStyle = 'rebeccapurple';\n      //     // 1.5 * radius is the length of the Hypotenuse\n      //     let theta = (startAngle + endAngle) / 2.0;\n      //     let deltaY = Math.sin(theta) * 1.5 * radius;\n      //     let deltaX = Math.cos(theta) * 1.5 * radius;\n      //     //point to label\n      //     this.context.strokeStyle = 'rebeccapurple';\n      //     this.context.moveTo(cx+deltaX/1.65, cy+deltaY/1.65);\n      //     this.context.lineTo((4*deltaX/5)+cx, (4*deltaY/5)+cy);\n      //     this.context.stroke();\n      //     //!!!Ian: name is the name of the stock category\n      //     this.context.fillText(element.name, deltaX+cx, deltaY+cy);\n      //     let percentage = Math.round(+((element.bookCost*100)/total));\n      //     this.context.fillText(percentage + \"%\", (deltaX*1.3)+cx, (deltaY*1.4)+cy);\n      //     this.context.closePath();\n      //     //store the slice information\n      //     this.state.slices.push({ \n      //             \"name\" : element.name,\n      //             \"colour\" : sliceColour,\n      //             \"startAngle\" : (2.0*Math.PI) - endAngle,    //since arc draws the slice backwards in clockwise fasion\n      //             \"endAngle\": (2.0*Math.PI) - startAngle,\n      //             \"drawStartAngle\": startAngle,\n      //             \"drawEndAngle\": endAngle,\n      //             \"bookCost\": element.bookCost\n      //     });\n      //     startAngle = endAngle;\n      // });\n      //console.log(this.state.slices)\n\n    };\n\n    this.barChartRef = /*#__PURE__*/React.createRef();\n  }\n\n  // drawAccentedSlice = (slice, accented) => {\n  //     let radius = parseFloat(this.state.radius);\n  //     let cx = parseFloat(this.state.canvasWidth/2);\n  //     let cy = parseFloat(this.state.canvasHeight/2);\n  //     this.context.strokeStyle = '#fafafa';\n  //     this.context.fillStyle = slice.colour;\n  //     this.context.beginPath();\n  //     // draw the pie wedges\n  //     this.context.moveTo(cx, cy);\n  //     this.context.arc(cx, cy, radius, slice.drawStartAngle, slice.drawEndAngle);\n  //     this.context.lineTo(cx, cy);\n  //     this.context.fill();\n  //     this.context.stroke();\n  //     this.context.closePath();\n  //     this.context.beginPath();  \n  //     this.context.font = '20px Helvetica, Calibri';\n  //     this.context.textAlign = 'center';\n  //     this.context.fillStyle = 'rebeccapurple';\n  //     this.context.strokeStyle = 'rebeccapurple';\n  //     let theta = (slice.drawStartAngle + slice.drawEndAngle) / 2.0;\n  //     let deltaY = parseFloat(Math.sin(theta) * 1.5 * radius);\n  //     let deltaX = parseFloat(Math.cos(theta) * 1.5 * radius);\n  //     // add the labels\n  //     if(accented == 1){\n  //         // this.context.moveTo(cx+deltaX/1.65, cy+deltaY/1.65);\n  //         // this.context.lineTo((4.0*deltaX/5)+cx, (4.0*deltaY/5)+cy);\n  //         // this.context.stroke();\n  //         //!!!Ian: name is the name of the stock category\n  //         this.context.fillText(\"$\" + slice.bookCost, deltaX/2+cx, deltaY/2+cy);\n  //         this.context.closePath();\n  //     }else{\n  //         this.context.translate(0.05, 0.05);\n  //         this.context.moveTo(parseFloat(cx+deltaX/1.65), parseFloat(cy+deltaY/1.65));\n  //         this.context.lineTo(parseFloat((4.0*deltaX/5)+cx), parseFloat((4.0*deltaY/5)+cy));\n  //         this.context.lineWidth = 3;\n  //         this.context.stroke();\n  //         this.context.closePath();\n  //         this.context.translate(-0.05, -0.05);\n  //     }\n  // }\n  componentDidMount() {\n    console.log(\"Did mount!\");\n    this.context = this.barChartRef.current.getContext('2d');\n    this.drawBars(); // this.context = this.pieChartRef.current.getContext('2d');\n    // let elem = document.getElementById('pieChartCanvas');\n    // const {listToDisplay} = this.props\n    // console.log(listToDisplay)\n    // this.drawSlices();\n    // //NOTE!!!!!! get bounding client rect gets the positions according to the window not the document!!!\n    // let rect = elem.getBoundingClientRect();\n    //add event listeners...I had to add it to a component so I used this one\n    // document.addEventListener('mousewheel', (e) => {\n    //     rect = elem.getBoundingClientRect();\n    // })\n    // document.addEventListener('mousemove', (e) => {\n    //     let mouseX=parseInt(e.clientX);\n    //     let mouseY=parseInt(e.clientY);\n    //     let cx = this.state.canvasWidth/2;\n    //     let cy = this.state.canvasHeight/2;\n    //     //mouse is relative to the window, rect is relative to the window\n    //     //cx and cy are fixed\n    //     //relativeX and relative Y are the distances from the center of the \"pie\"(no +ve or -ve signs)\n    //     let relativeX = 0;\n    //     let relativeY = 0;\n    //     let angle = 0;\n    //     // quadrant I & II:\n    //     if(mouseY > rect.y && mouseY < (rect.y + cy)){\n    //         relativeY = (cy + rect.y ) - mouseY;\n    //         //quadrant I:\n    //         if(mouseX > (rect.x + cx) && mouseX < rect.x + (2*cx)){\n    //             relativeX = mouseX - (cx + rect.x);\n    //             angle = Math.atan(relativeY/relativeX);\n    //             // console.log(relativeX)\n    //             // console.log(relativeY)\n    //             // console.log(\"quad I\")\n    //             // console.log(angle)\n    //         //quadrant II:\n    //         }else if(mouseX > rect.x && mouseX < (rect.x + cx)){\n    //             relativeX = (cx + rect.x) - mouseX;\n    //             angle = Math.PI - Math.atan(relativeY/relativeX);\n    //             // console.log(relativeX)\n    //             // console.log(relativeY)\n    //             // console.log(\"quad II\")\n    //             // console.log(angle)\n    //         }\n    //     //quadrant III & IV:\n    //     }else if (mouseY > cy + rect.y && mouseY < rect.y + (2*cy)){\n    //         relativeY = mouseY - (cy + rect.y);\n    //         //quadrant IV:\n    //         if(mouseX > (rect.x + cx) && mouseX < rect.x + (2*cx)){\n    //             relativeX = mouseX - (cx + rect.x);\n    //             angle = (2*Math.PI) - Math.atan(relativeY/relativeX);\n    //             // console.log(relativeX)\n    //             // console.log(relativeY)\n    //             // console.log(\"quad IV\")\n    //             // console.log(angle)\n    //         //quadrant III:\n    //         }else if(mouseX > rect.x && mouseX < (rect.x + cx)){\n    //             relativeX = (cx + rect.x) - mouseX;\n    //             angle = Math.PI + Math.atan(relativeY/relativeX);\n    //             // console.log(relativeX)\n    //             // console.log(relativeY)\n    //             // console.log(\"quad III\")\n    //             // console.log(angle)\n    //         }\n    //     }\n    //     //console.log(angle)\n    //     let distanceOk = false;\n    //     let distance = Math.sqrt( (relativeX * relativeX ) +  ( relativeY * relativeY));\n    //     if(distance < this.state.radius){\n    //         distanceOk = true;\n    //         // console.log(distance)\n    //         //console.log(\"Distance ok\")\n    //     }\n    //     for(let i=0;i<this.state.slices.length;i++){\n    //         let s=this.state.slices[i];\n    //         //check if the mouse angle matches with this slice\n    //         let angleOk = false;\n    //         if(s.startAngle < angle && angle < s.endAngle){\n    //             angleOk = true;\n    //             if(distanceOk){\n    //                 this.drawAccentedSlice(s, 1);\n    //                 setTimeout(this.drawAccentedSlice, 1000, s, 0);\n    //             }\n    //         }else continue;\n    //     }\n    // }); \n  } // componentDidUpdate() {        \n  //     this.context = this.pieChartRef.current.getContext('2d');\n  //     let elem = document.getElementById('pieChartCanvas');\n  //     let rect = elem.getBoundingClientRect();\n  //     const context = this.context;\n  //     //clear canvas\n  //     context.clearRect(0, 0, rect.width, rect.height);\n  //     context.beginPath();\n  //     //clear slices\n  //     this.state.slices = [];\n  //     this.drawSlices();//redraw\n  // }\n\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: \"barChartCanvas\",\n      ref: this.barChartRef,\n      width: \"1200\",\n      height: \"600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 294,\n      columnNumber: 11\n    }, this);\n  }\n\n}\n\nexport default BarChart;","map":{"version":3,"sources":["/Users/emilyhuang/Documents/CSC309/groupProject/team06/src/components/Investments/BarChart.js"],"names":["React","useRef","useEffect","useReducer","BarChart","Component","constructor","props","state","canvasWidth","canvasHeight","bars","graphWidth","graphHeight","randomPastelColourCode","Math","random","drawBars","listToDisplay","total","reduce","ttl","stock","bookCost","maxAmount","prev","current","gainLoss","console","log","minAmount","amountVertical","axisPosition","elem","document","getElementById","rect","getBoundingClientRect","context","lineWidth","strokeStyle","beginPath","moveTo","lineTo","stroke","closePath","barChartRef","createRef","componentDidMount","getContext","render"],"mappings":";AAAA;AAEA,OAAOA,KAAP,IAAgBC,MAAhB,EAAwBC,SAAxB,EAAmCC,UAAnC,QAAqD,OAArD;;;AAEA,MAAMC,QAAN,SAAuBJ,KAAK,CAACK,SAA7B,CAAuC;AASnCC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,UAAMA,KAAN;AADe,SARnBC,KAQmB,GARX;AACJC,MAAAA,WAAW,EAAE,IADT;AAEJC,MAAAA,YAAY,EAAE,GAFV;AAGJC,MAAAA,IAAI,EAAE,EAHF;AAIJC,MAAAA,UAAU,EAAE,IAJR;AAIa;AACjBC,MAAAA,WAAW,EAAE;AALT,KAQW;;AAAA,SAKnBC,sBALmB,GAKM,MAAM;AAC3B,aAAO,SAAS,MAAMC,IAAI,CAACC,MAAL,EAAf,GAA+B,GAA/B,IACD,KAAK,KAAKD,IAAI,CAACC,MAAL,EADT,IAC0B,IAD1B,IAED,KAAK,KAAKD,IAAI,CAACC,MAAL,EAFT,IAE0B,IAFjC;AAGH,KATkB;;AAAA,SAWnBC,QAXmB,GAWR,MAAM;AACb;AACA,YAAM;AAACC,QAAAA;AAAD,UAAkB,KAAKX,KAA7B;AAGA,UAAIY,KAAK,GAAGD,aAAa,CAACE,MAAd,CAAsB,CAACC,GAAD,EAAMC,KAAN,KAAgB;AAC9C,eAAOD,GAAG,GAAIC,KAAK,CAACC,QAApB;AACH,OAFW,EAET,CAFS,CAAZ,CALa,CASb;;AACA,YAAMC,SAAS,GAAGN,aAAa,CAACE,MAAd,CAAqB,UAASK,IAAT,EAAeC,OAAf,EAAwB;AAC3D,eAAQD,IAAI,CAACE,QAAL,GAAgBD,OAAO,CAACC,QAAzB,GAAqCF,IAArC,GAA4CC,OAAnD;AACH,OAFiB,CAAlB;AAGAE,MAAAA,OAAO,CAACC,GAAR,CAAYL,SAAZ;AAEA,YAAMM,SAAS,GAAGZ,aAAa,CAACE,MAAd,CAAqB,UAASK,IAAT,EAAeC,OAAf,EAAwB;AAC3D,eAAQD,IAAI,CAACE,QAAL,GAAgBD,OAAO,CAACC,QAAzB,GAAqCF,IAArC,GAA4CC,OAAnD;AACH,OAFiB,CAAlB;AAGAE,MAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAlBa,CAqBb;;AACA,UAAIC,cAAc,GAAG,CAArB;AACA,UAAIC,YAAY,GAAG,CAAnB;AACA,UAAIC,IAAI,GAAGC,QAAQ,CAACC,cAAT,CAAwB,gBAAxB,CAAX;AACA,UAAIC,IAAI,GAAGH,IAAI,CAACI,qBAAL,EAAX;;AACA,UAAGP,SAAS,CAACH,QAAV,GAAqB,CAAxB,EAA0B;AACtBC,QAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ;AACAE,QAAAA,cAAc,GAAGP,SAAS,GAAGM,SAA7B,CAFsB,CAGtB;;AACAE,QAAAA,YAAY,GAAG,IAAf;AACA,aAAKM,OAAL,CAAaC,SAAb,GAAyB,CAAzB;AACA,aAAKD,OAAL,CAAaE,WAAb,GAA2B,SAA3B;AACA,aAAKF,OAAL,CAAaG,SAAb;AACA,aAAKH,OAAL,CAAaI,MAAb,CAAoB,GAApB,EAAyB,IAAzB;AACA,aAAKJ,OAAL,CAAaK,MAAb,CAAoB,IAApB,EAA0B,GAA1B;AACA,aAAKL,OAAL,CAAaM,MAAb;AACA,aAAKN,OAAL,CAAaO,SAAb;AACH,OAZD,MAYK;AACDd,QAAAA,cAAc,GAAGP,SAAjB;AACH,OAxCY,CA6Cb;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACH,KA9GkB;;AAEf,SAAKsB,WAAL,gBAAmB9C,KAAK,CAAC+C,SAAN,EAAnB;AACH;;AA6GD;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEAC,EAAAA,iBAAiB,GAAG;AAChBpB,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACA,SAAKS,OAAL,GAAe,KAAKQ,WAAL,CAAiBpB,OAAjB,CAAyBuB,UAAzB,CAAoC,IAApC,CAAf;AACA,SAAKhC,QAAL,GAHgB,CAKhB;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,GA5QkC,CA8QnC;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;AAEAiC,EAAAA,MAAM,GAAG;AACL,wBACE;AAAQ,MAAA,EAAE,EAAG,gBAAb;AAA8B,MAAA,GAAG,EAAE,KAAKJ,WAAxC;AAAqD,MAAA,KAAK,EAAG,MAA7D;AAAoE,MAAA,MAAM,EAAG;AAA7E;AAAA;AAAA;AAAA;AAAA,YADF;AAGH;;AAnSkC;;AAsSvC,eAAe1C,QAAf","sourcesContent":["//Tutorials followed:\n\nimport React, { useRef, useEffect, useReducer } from 'react'\n\nclass BarChart extends React.Component {\n    state = {\n        canvasWidth: 1200,\n        canvasHeight: 600,\n        bars: [],\n        graphWidth: 1000,//style this in css to add padding on left and right\n        graphHeight: 500,\n    }\n\n    constructor(props) {\n        super(props);\n        this.barChartRef = React.createRef();\n    }\n\n    randomPastelColourCode = () => {\n        return \"hsl(\" + 360 * Math.random() + ',' +\n             (25 + 70 * Math.random()) + '%,' + \n             (80 + 10 * Math.random()) + '%)'\n    }\n\n    drawBars = () => {\n        //!!!Ian: bookCost is the total amount spend on that stock/in that category\n        const {listToDisplay} = this.props\n        \n        \n        let total = listToDisplay.reduce( (ttl, stock) => {\n            return ttl + (stock.bookCost)\n        }, 0);\n\n        //get the max and min gain loss stocks\n        const maxAmount = listToDisplay.reduce(function(prev, current) {\n            return (prev.gainLoss > current.gainLoss) ? prev : current\n        })\n        console.log(maxAmount)\n\n        const minAmount = listToDisplay.reduce(function(prev, current) {\n            return (prev.gainLoss < current.gainLoss) ? prev : current\n        })\n        console.log(minAmount)\n        \n\n        //based on the max and min values, calculate the corresponding ratios for the bar graph\n        let amountVertical = 0;\n        let axisPosition = 0;\n        let elem = document.getElementById('barChartCanvas');\n        let rect = elem.getBoundingClientRect();\n        if(minAmount.gainLoss < 0){\n            console.log(\"DRAWING\")\n            amountVertical = maxAmount - minAmount;\n            // axisPosition = (maxAmount/amountVertical) * this.graphHeight;\n            axisPosition = 1110;\n            this.context.lineWidth = 3;\n            this.context.strokeStyle = '#56525A';\n            this.context.beginPath();\n            this.context.moveTo(100, 1200);\n            this.context.lineTo(1100, 700);\n            this.context.stroke();\n            this.context.closePath();\n        }else{\n            amountVertical = maxAmount; \n        }\n        \n        \n        \n\n        // listToDisplay.forEach(element => {\n        //     //here the slices are draw backwards...(clockwise) so makesure to push into the list properly\n           \n        //     this.context.lineWidth = 3;\n        //     this.context.strokeStyle = '#fafafa';\n        //     this.context.fillStyle = this.randomPastelColourCode();\n        //     let sliceColour = this.context.fillStyle;\n        //     this.context.beginPath();\n            \n        //     // draw the pie wedges\n        //     let endAngle = ((element.bookCost / total) * Math.PI * 2) + startAngle;\n        //     this.context.moveTo(cx, cy);\n        //     this.context.arc(cx, cy, radius, startAngle, endAngle);\n        //     this.context.lineTo(cx, cy);\n        //     this.context.fill();\n        //     this.context.stroke();\n        //     this.context.closePath();\n            \n        //     // add the labels\n        //     this.context.beginPath();\n        //     this.context.font = '20px Helvetica, Calibri';\n        //     this.context.textAlign = 'center';\n        //     this.context.fillStyle = 'rebeccapurple';\n        //     // 1.5 * radius is the length of the Hypotenuse\n        //     let theta = (startAngle + endAngle) / 2.0;\n        //     let deltaY = Math.sin(theta) * 1.5 * radius;\n        //     let deltaX = Math.cos(theta) * 1.5 * radius;\n\n        //     //point to label\n        //     this.context.strokeStyle = 'rebeccapurple';\n        //     this.context.moveTo(cx+deltaX/1.65, cy+deltaY/1.65);\n        //     this.context.lineTo((4*deltaX/5)+cx, (4*deltaY/5)+cy);\n        //     this.context.stroke();\n\n        //     //!!!Ian: name is the name of the stock category\n        //     this.context.fillText(element.name, deltaX+cx, deltaY+cy);\n        //     let percentage = Math.round(+((element.bookCost*100)/total));\n        //     this.context.fillText(percentage + \"%\", (deltaX*1.3)+cx, (deltaY*1.4)+cy);\n        //     this.context.closePath();\n            \n\n        //     //store the slice information\n        //     this.state.slices.push({ \n        //             \"name\" : element.name,\n        //             \"colour\" : sliceColour,\n        //             \"startAngle\" : (2.0*Math.PI) - endAngle,    //since arc draws the slice backwards in clockwise fasion\n        //             \"endAngle\": (2.0*Math.PI) - startAngle,\n        //             \"drawStartAngle\": startAngle,\n        //             \"drawEndAngle\": endAngle,\n        //             \"bookCost\": element.bookCost\n        //     });\n        //     startAngle = endAngle;\n        // });\n        //console.log(this.state.slices)\n    }\n\n    // drawAccentedSlice = (slice, accented) => {\n    //     let radius = parseFloat(this.state.radius);\n    //     let cx = parseFloat(this.state.canvasWidth/2);\n    //     let cy = parseFloat(this.state.canvasHeight/2);\n    //     this.context.strokeStyle = '#fafafa';\n    //     this.context.fillStyle = slice.colour;\n        \n    //     this.context.beginPath();\n        \n    //     // draw the pie wedges\n    //     this.context.moveTo(cx, cy);\n    //     this.context.arc(cx, cy, radius, slice.drawStartAngle, slice.drawEndAngle);\n    //     this.context.lineTo(cx, cy);\n    //     this.context.fill();\n    //     this.context.stroke();\n    //     this.context.closePath();\n\n    //     this.context.beginPath();  \n    //     this.context.font = '20px Helvetica, Calibri';\n    //     this.context.textAlign = 'center';\n    //     this.context.fillStyle = 'rebeccapurple';\n    //     this.context.strokeStyle = 'rebeccapurple';\n\n    //     let theta = (slice.drawStartAngle + slice.drawEndAngle) / 2.0;\n    //     let deltaY = parseFloat(Math.sin(theta) * 1.5 * radius);\n    //     let deltaX = parseFloat(Math.cos(theta) * 1.5 * radius);\n        \n\n        \n    //     // add the labels\n    //     if(accented == 1){\n    //         // this.context.moveTo(cx+deltaX/1.65, cy+deltaY/1.65);\n    //         // this.context.lineTo((4.0*deltaX/5)+cx, (4.0*deltaY/5)+cy);\n    //         // this.context.stroke();\n\n    //         //!!!Ian: name is the name of the stock category\n    //         this.context.fillText(\"$\" + slice.bookCost, deltaX/2+cx, deltaY/2+cy);\n    //         this.context.closePath();\n    //     }else{\n    //         this.context.translate(0.05, 0.05);\n    //         this.context.moveTo(parseFloat(cx+deltaX/1.65), parseFloat(cy+deltaY/1.65));\n    //         this.context.lineTo(parseFloat((4.0*deltaX/5)+cx), parseFloat((4.0*deltaY/5)+cy));\n    //         this.context.lineWidth = 3;\n    //         this.context.stroke();\n    //         this.context.closePath();\n    //         this.context.translate(-0.05, -0.05);\n    //     }\n        \n    // }\n\n    componentDidMount() {\n        console.log(\"Did mount!\")\n        this.context = this.barChartRef.current.getContext('2d');\n        this.drawBars();\n        \n        // this.context = this.pieChartRef.current.getContext('2d');\n        // let elem = document.getElementById('pieChartCanvas');\n\n        // const {listToDisplay} = this.props\n        // console.log(listToDisplay)\n        // this.drawSlices();\n\n        // //NOTE!!!!!! get bounding client rect gets the positions according to the window not the document!!!\n        // let rect = elem.getBoundingClientRect();\n        \n        //add event listeners...I had to add it to a component so I used this one\n        // document.addEventListener('mousewheel', (e) => {\n        //     rect = elem.getBoundingClientRect();\n        // })\n\n        // document.addEventListener('mousemove', (e) => {\n    \n        //     let mouseX=parseInt(e.clientX);\n        //     let mouseY=parseInt(e.clientY);\n        //     let cx = this.state.canvasWidth/2;\n        //     let cy = this.state.canvasHeight/2;\n        //     //mouse is relative to the window, rect is relative to the window\n        //     //cx and cy are fixed\n        //     //relativeX and relative Y are the distances from the center of the \"pie\"(no +ve or -ve signs)\n        //     let relativeX = 0;\n        //     let relativeY = 0;\n        //     let angle = 0;\n      \n        //     // quadrant I & II:\n        //     if(mouseY > rect.y && mouseY < (rect.y + cy)){\n        //         relativeY = (cy + rect.y ) - mouseY;\n        //         //quadrant I:\n        //         if(mouseX > (rect.x + cx) && mouseX < rect.x + (2*cx)){\n        //             relativeX = mouseX - (cx + rect.x);\n        //             angle = Math.atan(relativeY/relativeX);\n        //             // console.log(relativeX)\n        //             // console.log(relativeY)\n        //             // console.log(\"quad I\")\n        //             // console.log(angle)\n        //         //quadrant II:\n        //         }else if(mouseX > rect.x && mouseX < (rect.x + cx)){\n        //             relativeX = (cx + rect.x) - mouseX;\n        //             angle = Math.PI - Math.atan(relativeY/relativeX);\n        //             // console.log(relativeX)\n        //             // console.log(relativeY)\n        //             // console.log(\"quad II\")\n        //             // console.log(angle)\n        //         }\n        //     //quadrant III & IV:\n        //     }else if (mouseY > cy + rect.y && mouseY < rect.y + (2*cy)){\n        //         relativeY = mouseY - (cy + rect.y);\n        //         //quadrant IV:\n        //         if(mouseX > (rect.x + cx) && mouseX < rect.x + (2*cx)){\n        //             relativeX = mouseX - (cx + rect.x);\n        //             angle = (2*Math.PI) - Math.atan(relativeY/relativeX);\n        //             // console.log(relativeX)\n        //             // console.log(relativeY)\n        //             // console.log(\"quad IV\")\n        //             // console.log(angle)\n        //         //quadrant III:\n        //         }else if(mouseX > rect.x && mouseX < (rect.x + cx)){\n        //             relativeX = (cx + rect.x) - mouseX;\n        //             angle = Math.PI + Math.atan(relativeY/relativeX);\n        //             // console.log(relativeX)\n        //             // console.log(relativeY)\n        //             // console.log(\"quad III\")\n        //             // console.log(angle)\n        //         }\n        //     }\n\n        //     //console.log(angle)\n        //     let distanceOk = false;\n        //     let distance = Math.sqrt( (relativeX * relativeX ) +  ( relativeY * relativeY));\n        //     if(distance < this.state.radius){\n        //         distanceOk = true;\n        //         // console.log(distance)\n        //         //console.log(\"Distance ok\")\n        //     }\n\n        //     for(let i=0;i<this.state.slices.length;i++){\n        //         let s=this.state.slices[i];\n        //         //check if the mouse angle matches with this slice\n        //         let angleOk = false;\n        //         if(s.startAngle < angle && angle < s.endAngle){\n        //             angleOk = true;\n        //             if(distanceOk){\n        //                 this.drawAccentedSlice(s, 1);\n        //                 setTimeout(this.drawAccentedSlice, 1000, s, 0);\n        //             }\n        //         }else continue;\n        //     }\n        // }); \n    }\n\n    // componentDidUpdate() {        \n    //     this.context = this.pieChartRef.current.getContext('2d');\n    //     let elem = document.getElementById('pieChartCanvas');\n    //     let rect = elem.getBoundingClientRect();\n        \n    //     const context = this.context;\n\n    //     //clear canvas\n    //     context.clearRect(0, 0, rect.width, rect.height);\n    //     context.beginPath();\n\n    //     //clear slices\n    //     this.state.slices = [];\n        \n    //     this.drawSlices();//redraw\n    // }\n    \n    render() {\n        return (\n          <canvas id = \"barChartCanvas\" ref={this.barChartRef} width = \"1200\" height = \"600\" />\n        )\n    }\n}\n\nexport default BarChart"]},"metadata":{},"sourceType":"module"}