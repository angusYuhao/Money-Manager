{"ast":null,"code":"var _jsxFileName = \"/Users/emilyhuang/Documents/CSC309/groupProject/team06/src/components/Investments/PieChart.js\";\n//Tutorials followed:\n//https://stackoverflow.com/questions/33924150/how-to-access-canvas-context-in-react\n//https://stackoverflow.com/questions/27736288/how-to-fill-the-whole-canvas-with-specific-color\n//https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\n//https://gist.github.com/prof3ssorSt3v3/7f16fe9397c013d364f2d4484cad3ca8\n//https://stackoverflow.com/questions/30790010/html-canvas-hover-text\n//https://stackoverflow.com/questions/6270785/how-to-determine-whether-a-point-x-y-is-contained-within-an-arc-section-of-a-c\n//https://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing\nimport React, { useRef, useEffect, useReducer } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass PieChart extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      canvasWidth: 600,\n      canvasHeight: 600\n    };\n\n    this.randomHexColorCode = () => {\n      return \"#\" + Math.random().toString(16).slice(2, 8);\n    };\n\n    this.drawSlices = () => {\n      let startAngle = 0;\n      let radius = 120;\n      let cx = this.state.canvasWidth / 2;\n      let cy = this.state.canvasHeight / 2;\n      stockList.forEach(element => {\n        console.log(\"Drawing slice\");\n        this.context.lineWidth = 1;\n        this.context.strokeStyle = '#fafafa';\n        this.context.fillStyle = this.randomHexColorCode();\n        this.context.beginPath(); // draw the pie wedges\n\n        let endAngle = element.avgCost * element.quantity / total * Math.PI * 2 + startAngle;\n        this.context.moveTo(cx, cy);\n        this.context.arc(cx, cy, radius, startAngle, endAngle);\n        this.context.lineTo(cx, cy);\n        this.context.fill();\n        this.context.stroke();\n        this.context.closePath(); // add the labels\n\n        this.context.beginPath();\n        this.context.font = '20px Helvetica, Calibri';\n        this.context.textAlign = 'center';\n        this.context.fillStyle = 'rebeccapurple'; // 1.5 * radius is the length of the Hypotenuse\n\n        let theta = (startAngle + endAngle) / 2;\n        let deltaY = Math.sin(theta) * 1.5 * radius;\n        let deltaX = Math.cos(theta) * 1.5 * radius;\n        this.context.fillText(element.name, deltaX + cx, deltaY + cy);\n        let percentage = Math.round(+(element.avgCost * element.quantity * 100 / total));\n        this.context.fillText(percentage + \"%\", deltaX * 1.3 + cx, deltaY * 1.4 + cy);\n        this.context.closePath(); //store the slice information\n\n        slices.push({\n          \"name\": element.name,\n          \"cx\": cx,\n          \"cy\": cy,\n          \"colour\": this.context.fillStyle,\n          \"radius\": radius,\n          \"startAngle\": startAngle,\n          \"endAngle\": endAngle\n        });\n        startAngle = endAngle;\n      });\n    };\n\n    this.width = 0;\n    this.height = 0;\n    this.pieChartRef = /*#__PURE__*/React.createRef();\n  } // let elem = document.querySelector('canvas');\n  // let rect = elem.getBoundingClientRect();\n  // console.log(rect);\n\n\n  componentDidMount() {\n    console.log(\"Did mount!\");\n    this.context = this.pieChartRef.current.getContext('2d'); // let elem = document.querySelector('canvas');\n    // let rect = elem.getBoundingClientRect();\n    // console.log(rect);\n\n    let slices = [];\n    const {\n      stockList\n    } = this.props;\n    console.log(stockList);\n    let total = stockList.reduce((ttl, stock) => {\n      return ttl + stock.avgCost * stock.quantity;\n    }, 0);\n    drawSlices();\n    document.addEventListener('mousemove', e => {\n      let mouseX = parseInt(e.clientX);\n      let mouseY = parseInt(e.clientY); // console.log(e.pageX)\n      // console.log(e.pageY)\n      // console.log(e.clientX)\n      // console.log(e.clientY)\n\n      for (let i = 0; i < slices.length; i++) {\n        let s = slices[i]; // define the shape path we want to test against the mouse position\n        // defineShape(s.points);\n        //check the angle\n\n        let angleOk = false;\n        let angle = Math.atan(mouseY - cy, mouseX - cx); // let mouseAngle = Math.atan(e.pageY - cy,e.pageX - cx);\n\n        if (s.startAngle < s.endAngle && s.startAngle < angle && angle < s.endAngle) {\n          //console.log(\"Angle ok\")\n          angleOk = true;\n        } else if (s.startAngle > s.endAngle) {\n          if (angle > s.startAngle || angle < s.endAngle) {\n            //console.log(\"Angle ok\")\n            angleOk = true;\n          }\n        } //check the radius\n\n\n        let distanceOk = false; //this distance is wrong:\n\n        let distance = Math.sqrt((mouseX - cx) * (mouseX - cx) + (mouseY - cy) * (mouseY - cy));\n        console.log(mouseX);\n        console.log(mouseY); // console.log(cx)\n        // console.log(cy)\n\n        if (distance < s.radius) {\n          distanceOk = true; // console.log(distance)\n          // console.log(\"Distance ok\")\n        } //all the slices \n\n\n        if (angleOk && distanceOk) {\n          // if yes, fill the shape in red\n          console.log(\"hovering over slice\"); //   s.drawcolor='red';\n        } else {// if no, fill the shape with blue\n            //   s.drawcolor=s.colour;\n          }\n      }\n    });\n  }\n\n  componentDidUpdate() {\n    console.log(\"Did update!\");\n    let elem = document.querySelector('canvas');\n    let rect = elem.getBoundingClientRect();\n    console.log(rect);\n    console.log(rect.x);\n    console.log(rect.y);\n    console.log(rect.width);\n    console.log(rect.height);\n    this.context = this.pieChartRef.current.getContext('2d');\n    const context = this.context;\n    context.clearRect(rect.x, rect.y, rect.width, rect.height);\n    context.beginPath(); //context.save();\n    //context.setTransform(1, 0, 0, 1, 0, 0);\n    //context.beginPath();\n    //context.restore();\n\n    let slices = [];\n    const {\n      stockList\n    } = this.props;\n    console.log(stockList);\n    let total = stockList.reduce((ttl, stock) => {\n      return ttl + stock.avgCost * stock.quantity;\n    }, 0);\n    console.log(\"total\");\n    console.log(total);\n    let startAngle = 0;\n    let radius = 120;\n    let cx = this.state.canvasWidth / 2;\n    let cy = this.state.canvasHeight / 2;\n    stockList.forEach(element => {\n      console.log(\"Drawing slice\");\n      this.context.lineWidth = 1;\n      this.context.strokeStyle = '#fafafa';\n      this.context.fillStyle = this.randomHexColorCode();\n      this.context.beginPath(); // draw the pie wedges\n\n      let endAngle = element.avgCost * element.quantity / total * Math.PI * 2 + startAngle;\n      this.context.moveTo(cx, cy);\n      this.context.arc(cx, cy, radius, startAngle, endAngle);\n      this.context.lineTo(cx, cy);\n      this.context.fill();\n      this.context.stroke();\n      this.context.closePath(); // add the labels\n\n      this.context.beginPath();\n      this.context.font = '20px Helvetica, Calibri';\n      this.context.textAlign = 'center';\n      this.context.fillStyle = 'rebeccapurple'; // 1.5 * radius is the length of the Hypotenuse\n\n      let theta = (startAngle + endAngle) / 2;\n      let deltaY = Math.sin(theta) * 1.5 * radius;\n      let deltaX = Math.cos(theta) * 1.5 * radius;\n      this.context.fillText(element.name, deltaX + cx, deltaY + cy);\n      let percentage = Math.round(+(element.avgCost * element.quantity * 100 / total));\n      this.context.fillText(percentage + \"%\", deltaX * 1.3 + cx, deltaY * 1.4 + cy);\n      this.context.closePath(); //store the slice information\n\n      slices.push({\n        \"name\": element.name,\n        \"cx\": cx,\n        \"cy\": cy,\n        \"colour\": this.context.fillStyle,\n        \"radius\": radius,\n        \"startAngle\": startAngle,\n        \"endAngle\": endAngle\n      });\n      startAngle = endAngle;\n    });\n    document.addEventListener('mousemove', e => {\n      let mouseX = parseInt(e.clientX);\n      let mouseY = parseInt(e.clientY); // console.log(e.pageX)\n      // console.log(e.pageY)\n      // console.log(e.clientX)\n      // console.log(e.clientY)\n\n      for (let i = 0; i < slices.length; i++) {\n        let s = slices[i]; // define the shape path we want to test against the mouse position\n        // defineShape(s.points);\n        //check the angle\n\n        let angleOk = false;\n        let angle = Math.atan(mouseY - cy, mouseX - cx); // let mouseAngle = Math.atan(e.pageY - cy,e.pageX - cx);\n\n        if (s.startAngle < s.endAngle && s.startAngle < angle && angle < s.endAngle) {\n          //console.log(\"Angle ok\")\n          angleOk = true;\n        } else if (s.startAngle > s.endAngle) {\n          if (angle > s.startAngle || angle < s.endAngle) {\n            //console.log(\"Angle ok\")\n            angleOk = true;\n          }\n        } //check the radius\n\n\n        let distanceOk = false; //this distance is wrong:\n\n        let distance = Math.sqrt((mouseX - (cx + rect.x)) * (mouseX - (cx + rect.x)) + (mouseY - (cy + rect.y)) * (mouseY - (cy + rect.y)));\n        console.log(mouseX);\n        console.log(mouseY); // console.log(cx)\n        // console.log(cy)\n\n        if (distance < s.radius) {\n          distanceOk = true; // console.log(distance)\n\n          console.log(\"Distance ok\");\n        } //all the slices \n\n\n        if (angleOk && distanceOk) {\n          // if yes, fill the shape in red\n          console.log(\"hovering over slice\"); //   s.drawcolor='red';\n        } else {// if no, fill the shape with blue\n            //   s.drawcolor=s.colour;\n          }\n      }\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: this.pieChartRef,\n      width: this.state.canvasWidth,\n      height: this.state.canvasHeight\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 331,\n      columnNumber: 11\n    }, this);\n  }\n\n}\n\nexport default PieChart;","map":{"version":3,"sources":["/Users/emilyhuang/Documents/CSC309/groupProject/team06/src/components/Investments/PieChart.js"],"names":["React","useRef","useEffect","useReducer","PieChart","Component","constructor","props","state","canvasWidth","canvasHeight","randomHexColorCode","Math","random","toString","slice","drawSlices","startAngle","radius","cx","cy","stockList","forEach","element","console","log","context","lineWidth","strokeStyle","fillStyle","beginPath","endAngle","avgCost","quantity","total","PI","moveTo","arc","lineTo","fill","stroke","closePath","font","textAlign","theta","deltaY","sin","deltaX","cos","fillText","name","percentage","round","slices","push","width","height","pieChartRef","createRef","componentDidMount","current","getContext","reduce","ttl","stock","document","addEventListener","e","mouseX","parseInt","clientX","mouseY","clientY","i","length","s","angleOk","angle","atan","distanceOk","distance","sqrt","componentDidUpdate","elem","querySelector","rect","getBoundingClientRect","x","y","clearRect","render"],"mappings":"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","sourcesContent":["//Tutorials followed:\n//https://stackoverflow.com/questions/33924150/how-to-access-canvas-context-in-react\n//https://stackoverflow.com/questions/27736288/how-to-fill-the-whole-canvas-with-specific-color\n//https://medium.com/@pdx.lucasm/canvas-with-react-js-32e133c05258\n//https://gist.github.com/prof3ssorSt3v3/7f16fe9397c013d364f2d4484cad3ca8\n//https://stackoverflow.com/questions/30790010/html-canvas-hover-text\n//https://stackoverflow.com/questions/6270785/how-to-determine-whether-a-point-x-y-is-contained-within-an-arc-section-of-a-c\n//https://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing\n\n\n\nimport React, { useRef, useEffect, useReducer } from 'react'\n\nclass PieChart extends React.Component {\n    state = {\n        canvasWidth: 600,\n        canvasHeight: 600,\n    }\n    constructor(props) {\n        super(props);\n        this.width = 0;\n        this.height = 0;\n        this.pieChartRef = React.createRef();\n    }\n    \n    // let elem = document.querySelector('canvas');\n    // let rect = elem.getBoundingClientRect();\n    // console.log(rect);\n\n    randomHexColorCode = () => {\n        return \"#\" + Math.random().toString(16).slice(2, 8)\n    }\n\n    drawSlices = () => {\n        let startAngle = 0; \n        let radius = 120;\n        let cx = this.state.canvasWidth/2;\n        let cy = this.state.canvasHeight/2;\n        \n\n        stockList.forEach(element => {\n            console.log(\"Drawing slice\")\n            this.context.lineWidth = 1;\n            this.context.strokeStyle = '#fafafa';\n            this.context.fillStyle = this.randomHexColorCode();\n            this.context.beginPath();\n            \n            // draw the pie wedges\n            let endAngle = (((element.avgCost * element.quantity) / total) * Math.PI * 2) + startAngle;\n            this.context.moveTo(cx, cy);\n            this.context.arc(cx, cy, radius, startAngle, endAngle);\n            this.context.lineTo(cx, cy);\n            this.context.fill();\n            this.context.stroke();\n            this.context.closePath();\n            \n            // add the labels\n            this.context.beginPath();\n            this.context.font = '20px Helvetica, Calibri';\n            this.context.textAlign = 'center';\n            this.context.fillStyle = 'rebeccapurple';\n            // 1.5 * radius is the length of the Hypotenuse\n            let theta = (startAngle + endAngle) / 2;\n            let deltaY = Math.sin(theta) * 1.5 * radius;\n            let deltaX = Math.cos(theta) * 1.5 * radius;\n            this.context.fillText(element.name, deltaX+cx, deltaY+cy);\n            let percentage = Math.round(+((element.avgCost*element.quantity*100)/total));\n            this.context.fillText(percentage + \"%\", (deltaX*1.3)+cx, (deltaY*1.4)+cy);\n            this.context.closePath();\n            \n\n            //store the slice information\n            slices.push({ \n                    \"name\" : element.name,\n                    \"cx\" : cx,\n                    \"cy\" : cy,\n                    \"colour\" : this.context.fillStyle,\n                    \"radius\" : radius,\n                    \"startAngle\" : startAngle,\n                    \"endAngle\": endAngle,\n            });\n            startAngle = endAngle;\n        });\n    }\n\n    componentDidMount() {\n        console.log(\"Did mount!\")\n        this.context = this.pieChartRef.current.getContext('2d');\n        // let elem = document.querySelector('canvas');\n        // let rect = elem.getBoundingClientRect();\n        // console.log(rect);\n        let slices = [];\n        const {stockList} = this.props\n        console.log(stockList)\n        \n        let total = stockList.reduce( (ttl, stock) => {\n            return ttl + (stock.avgCost * stock.quantity)\n        }, 0);\n        \n        drawSlices();\n        \n\n        document.addEventListener('mousemove', (e) => {\n            let mouseX=parseInt(e.clientX);\n            let mouseY=parseInt(e.clientY);\n            // console.log(e.pageX)\n            // console.log(e.pageY)\n            // console.log(e.clientX)\n            // console.log(e.clientY)\n\n                    \n            for(let i=0;i<slices.length;i++){\n                let s=slices[i];\n            \n                // define the shape path we want to test against the mouse position\n                // defineShape(s.points);\n                \n                //check the angle\n                let angleOk = false;\n                let angle = Math.atan(mouseY - cy,mouseX - cx);\n                // let mouseAngle = Math.atan(e.pageY - cy,e.pageX - cx);\n         \n                if(s.startAngle < s.endAngle && s.startAngle < angle && angle < s.endAngle){\n                    //console.log(\"Angle ok\")\n                    angleOk = true;\n\n\n                }else if(s.startAngle > s.endAngle){\n                    if(angle > s.startAngle || angle < s.endAngle){\n                        //console.log(\"Angle ok\")\n                        angleOk = true;\n\n\n\n                    }\n                }\n                \n                //check the radius\n                let distanceOk = false;\n                //this distance is wrong:\n                let distance = Math.sqrt( ((mouseX - cx) * (mouseX - cx)) +  ((mouseY - cy) * (mouseY - cy)) );\n                \n                \n                \n                console.log(mouseX)\n                console.log(mouseY)\n                // console.log(cx)\n                // console.log(cy)\n\n\n                if(distance < s.radius){\n                    distanceOk = true;\n                    // console.log(distance)\n                    // console.log(\"Distance ok\")\n                }\n\n                //all the slices \n                if(angleOk && distanceOk){\n                  // if yes, fill the shape in red\n                  console.log(\"hovering over slice\")\n\n                //   s.drawcolor='red';\n                  \n                }else{\n                  // if no, fill the shape with blue\n                //   s.drawcolor=s.colour;\n                }\n                \n              }\n        }); \n    }\n\n    componentDidUpdate() {\n        console.log(\"Did update!\")\n        let elem  = document.querySelector('canvas');\n        let rect = elem.getBoundingClientRect();\n        console.log(rect);\n        console.log(rect.x)\n        console.log(rect.y)\n        console.log(rect.width)\n        console.log(rect.height)\n        this.context = this.pieChartRef.current.getContext('2d');\n        const context = this.context;\n        context.clearRect(rect.x, rect.y, rect.width, rect.height);\n        context.beginPath();\n        \n\n        \n        //context.save();\n        //context.setTransform(1, 0, 0, 1, 0, 0);\n        //context.beginPath();\n       \n\n        \n        //context.restore();\n        \n        \n        let slices = [];\n        const {stockList} = this.props\n        console.log(stockList)\n        \n        let total = stockList.reduce( (ttl, stock) => {\n            return ttl + (stock.avgCost * stock.quantity)\n        }, 0);\n        console.log(\"total\")\n        console.log(total)\n        let startAngle = 0; \n        let radius = 120;\n        let cx = this.state.canvasWidth/2;\n        let cy = this.state.canvasHeight/2;\n        \n\n        \n\n        stockList.forEach(element => {\n            console.log(\"Drawing slice\")\n            this.context.lineWidth = 1;\n            this.context.strokeStyle = '#fafafa';\n            this.context.fillStyle = this.randomHexColorCode();\n            this.context.beginPath();\n            \n            // draw the pie wedges\n            let endAngle = (((element.avgCost * element.quantity) / total) * Math.PI * 2) + startAngle;\n            this.context.moveTo(cx, cy);\n            this.context.arc(cx, cy, radius, startAngle, endAngle);\n            this.context.lineTo(cx, cy);\n            this.context.fill();\n            this.context.stroke();\n            this.context.closePath();\n            \n            // add the labels\n            this.context.beginPath();\n            this.context.font = '20px Helvetica, Calibri';\n            this.context.textAlign = 'center';\n            this.context.fillStyle = 'rebeccapurple';\n            // 1.5 * radius is the length of the Hypotenuse\n            let theta = (startAngle + endAngle) / 2;\n            let deltaY = Math.sin(theta) * 1.5 * radius;\n            let deltaX = Math.cos(theta) * 1.5 * radius;\n            this.context.fillText(element.name, deltaX+cx, deltaY+cy);\n            let percentage = Math.round(+((element.avgCost*element.quantity*100)/total));\n            this.context.fillText(percentage + \"%\", (deltaX*1.3)+cx, (deltaY*1.4)+cy);\n            this.context.closePath();\n            \n\n            //store the slice information\n            slices.push({ \n                    \"name\" : element.name,\n                    \"cx\" : cx,\n                    \"cy\" : cy,\n                    \"colour\" : this.context.fillStyle,\n                    \"radius\" : radius,\n                    \"startAngle\" : startAngle,\n                    \"endAngle\": endAngle,\n            });\n            startAngle = endAngle;\n        });\n\n        document.addEventListener('mousemove', (e) => {\n            let mouseX=parseInt(e.clientX);\n            let mouseY=parseInt(e.clientY);\n            // console.log(e.pageX)\n            // console.log(e.pageY)\n            // console.log(e.clientX)\n            // console.log(e.clientY)\n\n                    \n            for(let i=0;i<slices.length;i++){\n                let s=slices[i];\n            \n                // define the shape path we want to test against the mouse position\n                // defineShape(s.points);\n                \n                //check the angle\n                let angleOk = false;\n                let angle = Math.atan(mouseY - cy,mouseX - cx);\n                // let mouseAngle = Math.atan(e.pageY - cy,e.pageX - cx);\n         \n                if(s.startAngle < s.endAngle && s.startAngle < angle && angle < s.endAngle){\n                    //console.log(\"Angle ok\")\n                    angleOk = true;\n\n\n                }else if(s.startAngle > s.endAngle){\n                    if(angle > s.startAngle || angle < s.endAngle){\n                        //console.log(\"Angle ok\")\n                        angleOk = true;\n\n\n\n                    }\n                }\n                \n                //check the radius\n                let distanceOk = false;\n                //this distance is wrong:\n                let distance = Math.sqrt( ((mouseX - (cx+rect.x)) * (mouseX - (cx+rect.x))) +  ((mouseY - (cy+rect.y)) * (mouseY - (cy+rect.y))) );\n                \n                \n                \n                console.log(mouseX)\n                console.log(mouseY)\n                // console.log(cx)\n                // console.log(cy)\n\n\n                if(distance < s.radius){\n                    distanceOk = true;\n                    // console.log(distance)\n                    console.log(\"Distance ok\")\n                }\n\n                //all the slices \n                if(angleOk && distanceOk){\n                  // if yes, fill the shape in red\n                  console.log(\"hovering over slice\")\n\n                //   s.drawcolor='red';\n                  \n                }else{\n                  // if no, fill the shape with blue\n                //   s.drawcolor=s.colour;\n                }\n                \n              }\n        }); \n    }\n    \n    render() {\n        return (\n          <canvas ref={this.pieChartRef} width = {this.state.canvasWidth} height = {this.state.canvasHeight} />\n       )\n    }\n}\n\nexport default PieChart"]},"metadata":{},"sourceType":"module"}